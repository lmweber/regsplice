---
title: "Example workflow for *regsplice* package"
author: "Lukas M. Weber"
date: "`r doc_date()`"
package: "`r pkg_ver('regsplice')`"
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Example workflow for regsplice package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

\pagebreak



# Introduction

The *regsplice* package implements statistical methods for the detection of differential exon usage (differential splicing) in RNA sequencing (RNA-seq) and microarray data sets. The *regsplice* methods are fast and make use of the lasso to improve power compared to standard generalized linear models. The methodology and comparisons to previous approaches are described in our paper:

> Title of paper and link to bioRxiv preprint here.



## Example workflow

This vignette demonstrates an example workflow for the *regsplice* package using a small simulated RNA-seq data set.

There are two options for running *regsplice*: you can run a complete workflow in one step using the wrapper function `regsplice`; or you can run the individual functions for each step in sequence, which provides additional insight into the methodology. Both options are demonstrated below.



## Data set

The data set used for the workflow consists of exon-level read counts for a subset of 100 genes from a simulated human RNA-seq data set, consisting of 6 biological samples, with 3 samples in each of 2 conditions.

The original data set is from the paper:

> Soneson et al. (2016), *Isoform prefiltering improves performance of count-based methods for analysis of differential transcript usage*, Genome Biology, [available here](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0862-3).

Original data files from this paper, containing the simulated RNA-seq reads (FASTQ and BAM files), are available from ArrayExpress at accession code [E-MTAB-3766](http://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-3766/).

Exon bin counts were generated with the Python counting scripts provided with the *DEXSeq* package, using the option to exclude exons from overlapping genes instead of aggregating them into multi-gene complexes (see Soneson et al. 2016, Supplementary Material).

For this workflow, we have selected a subset of the first 100 genes from this simulated data set. The exon-level read counts and the true differential splicing status labels for these 100 genes are saved as tab-delimited TXT files in the `extdata/` directory in the *regsplice* package source code.



## SummarizedExperiment class

The *regsplice* package uses the `SummarizedExperiment` S4 class to enable easier integration into Bioconductor workflows. The `SummarizedExperiment` class stores matrices of data values (such as RNA-seq read counts or microarray expression intensities) along with associated meta-data for rows (genes or exons) and columns (biological samples).

The main benefit of using `SummarizedExperiment` objects is that subsetting operations work intuitively, keeping data and meta-data in sync. The `SummarizedExperiment` class replaces the earlier `ExpressionSet` class. For more information, see the `SummarizedExperiment` Bioconductor vignette, [available here](http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html).




# Workflow

## Complete workflow with wrapper function

..... to do:

How to run a complete workflow in a single step using the `regsplice` wrapper function

You can provide the data either as filenames / matrices, or as a `SummarizedExperiment` object. If you provide filenames or matrices, you also need to provide gene and exon indices, so that *regsplice* can create the `SummarizedExperiment` object automatically.

...

Below, we show how to run the functions for the individual steps in the *regsplice* workflow in sequence, which provides additional flexibility and insight into the methodology.



## Individual steps

### Load data

Load the demo data file, which contains simulated RNA-seq read counts for 100 genes across 6 biological samples.

```{r}
file_counts <- system.file("extdata/counts.txt", package = "regsplice")

data <- read.table(file_counts, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

dim(data)
head(data, 3)

# extract counts and gene/exon identifiers for each row
counts <- data[, 2:7]
gene <- sapply(strsplit(data$exon, ":"), function(s) s[[1]])
exon <- sapply(strsplit(data$exon, ":"), function(s) s[[2]])

# create meta-data for biological samples
condition <- rep(c("untreated", "treated"), each = 3)
```



### Create SummarizedExperiment object

Create a `SummarizedExperiment` object containing the data (counts), as well as meta-data for rows (genes and exons) and columns (biological samples).

This can be done using the `prepare_data()` function, which requires a matrix or data frame of counts, and character vectors containing the gene and exon identifiers. Optionally, the `exon` argument can be left empty, in which case the exons within each gene will be numbered sequentially.

The row and column meta-data can be accessed with `S4Vectors::mcols()` and `SummarizedExperiment::colData()`.

```{r}
suppressPackageStartupMessages(library(regsplice))
suppressPackageStartupMessages(library(SummarizedExperiment))

se <- prepare_data(counts = counts, gene = gene, exon = exon, condition = condition)

str(se, max.level = 1)

mcols(se)

colData(se)
```



### Create design matrices

The `create_design_matrix()` function is used to create design matrices for each gene. This function will be called automatically by the model fitting functions. Here, we demonstrate how it works for a simple example. Note there is no intercept term, since this is added back automatically by *glmnet*.

```{r}
# design matrix for gene with 3 exons; 4 samples (2 samples in each of 2 conditions)
design_mat <- create_design_matrix(condition = rep(c(0, 1), each = 2), n_exons = 3)

design_mat
```



### Fit models and calculate likelihood ratio tests

```{r}
# load data
file_counts <- system.file("extdata/counts.txt", package = "regsplice")
data <- read.table(file_counts, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
counts <- data[, 2:7]
gene <- sapply(strsplit(data$exon, ":"), function(s) s[[1]])

# prepare data
Y <- prepare_data(counts, gene)

# fit models
fit_reg  <- fit_models_reg(Y = Y, condition = condition)  ### can use n_cores = 4 on Mac
fit_GLM  <- fit_models_GLM(Y = Y, condition = condition)
fit_null <- fit_models_null(Y = Y, condition = condition)

# calculate likelihood ratio tests
LR_tests(fit_reg = fit_reg, fit_GLM = fit_GLM, fit_null = fit_null, when_null_selected = "ones")

```


### Plot

```{r}
plot(p_vals[order(p_vals)], type = "b")
plot(p_adj[order(p_adj)], type = "b")

```



### Calculate likelihood ratio tests






# Additional steps for microarray data

If you are using microarray data, you also need to use limma/voom to convert data...

give example code








Vignette info


Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
#plot(1:10)
#plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.



Math expressions

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
#knitr::kable(head(mtcars, 10))
```


