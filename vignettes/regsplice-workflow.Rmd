---
title: "Example workflow for *regsplice* package"
author: "Lukas M. Weber"
date: "`r doc_date()`"
package: "`r pkg_ver('regsplice')`"
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Example workflow for regsplice package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

\pagebreak



# Introduction

The *regsplice* package implements statistical methods for the detection of differential exon usage (differential splicing) in RNA sequencing (RNA-seq) and microarray data sets.

The *regsplice* methods are based on the use of the lasso (L1-regularization) to improve the power of standard generalized linear models, with fast runtimes compared to other leading approaches. The statistical methodology and comparisons to other methods are described in our paper:

> Title of paper and link to bioRxiv preprint here.



## Example workflow

This vignette demonstrates an example workflow for the *regsplice* package using a small simulated RNA-seq data set.

There are two options for running *regsplice*: you can run a complete workflow in one step using the wrapper function `regsplice()`; or you can run the individual functions for each step in sequence, which provides additional insight into the methodology. Both options are demonstrated below.



## Data set

The data set used for the workflow consists of exon-level read counts for a subset of 100 genes from a simulated human RNA-seq data set, consisting of 6 biological samples, with 3 samples in each of 2 conditions.

The original data set is from the paper:

> Soneson et al. (2016), *Isoform prefiltering improves performance of count-based methods for analysis of differential transcript usage*, Genome Biology, [available here](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0862-3).

Original data files from this paper, containing the simulated RNA-seq reads (FASTQ and BAM files), are available from ArrayExpress at accession code [E-MTAB-3766](http://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-3766/).

Exon bin counts were generated with the Python counting scripts provided with the *DEXSeq* package, using the option to exclude exons from overlapping genes instead of aggregating them into multi-gene complexes (see Soneson et al. 2016, Supplementary Material).

For this workflow, we have selected a subset of the first 100 genes from this simulated data set. The exon-level read counts and the true differential splicing status labels for these 100 genes are saved as tab-delimited `.txt` files in the `extdata/` directory in the *regsplice* package source code.



# Workflow

## Complete workflow with wrapper function

..... to do:

How to run a complete workflow in a single step using the `regsplice()` wrapper function

You can provide the data either as filenames or matrices / data frames. Also need gene/exon IDs etc.

...

Below, we show how to run the functions for the individual steps in the *regsplice* workflow in sequence, which provides additional flexibility and insight into the methodology.



## Individual steps

### Load data

Load the demo data file, which contains simulated RNA-seq read counts for 100 genes across 6 biological samples.

\vspace{6pt}

```{r}
file_counts <- system.file("extdata/counts.txt", package = "regsplice")
data <- read.table(file_counts, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

head(data, 3)
dim(data)

# extract counts and gene/exon identifiers
counts <- data[, 2:7]
gene <- sapply(strsplit(data$exon, ":"), function(s) s[[1]])
exon <- sapply(strsplit(data$exon, ":"), function(s) s[[2]])

head(gene, 3)
head(exon, 3)

# create meta-data for biological samples
condition <- rep(c("untreated", "treated"), each = 3)
condition
```



### Prepare data

Run the function `prepare_data()` to prepare the data into the correct format for subsequent steps. This splits the matrix (or data frame) of RNA-seq counts into a list of sub-matrices, where each sub-matrix contains the counts for one gene. The length of each gene (i.e. the number of exons) is taken from the number of repeated entries in the vector of gene identifiers.

\vspace{6pt}

```{r}
library(regsplice)

Y <- prepare_data(counts = counts, gene = gene)
```



### Create design matrices

The function `create_design_matrix()` creates design matrices for each gene. This function is called automatically by the model fitting functions in subsequent steps. Here, we demonstrate how it works for a simple example. Note there is no intercept term, since this is added back automatically by the model fitting functions.

\vspace{6pt}

```{r}
# gene with 3 exons; 4 biological samples, 2 samples in each of 2 conditions
design_example <- create_design_matrix(condition = rep(c(0, 1), each = 2), n_exons = 3)
design_example
```



### Fit models

There are three model fitting functions: `fit_reg()`, `fit_GLM()`, and `fit_null()`. These fit the regularized (lasso) models; full GLMs containing interaction terms for every exon; and null models without interaction terms, for every gene.

The model fitting functions are parallelized, with the `n_cores` argument controlling the number of cores. For `fit_reg()`, the default is the number of available cores up to a maximum of 8. For `fit_GLM()` and `fit_null()`, the default is a single core, since these functions are extremely fast; if they take longer than a few seconds for your data set, it may be beneficial to try increasing the number of cores.

\vspace{6pt}

```{r}
# fit regularized models
fit_reg <- fit_models_reg(Y = Y, condition = condition)

# fit GLMs
fit_GLM  <- fit_models_GLM(Y = Y, condition = condition)

# fit null models
fit_null <- fit_models_null(Y = Y, condition = condition)
```



### Calculate likelihood ratio tests

The function `LR_tests()` calculates likelihood ratio tests for each gene, using the fitted models from the previous step.

explain option: when-null-selected. Here we use the option `when_null_selected = "ones"`; explained in paper.

fit-glm can be null

```{r}
# calculate likelihood ratio tests
res <- LR_tests(fit_reg = fit_reg, fit_GLM = fit_GLM, fit_null = fit_null, 
                when_null_selected = "ones")
```



### Plot

Plot results: p-values and adjusted p-values from previous step

replace with visualization functions in a new file visualize-results.R

```{r}
# p-values
plot(res$p_vals[order(res$p_vals)], type = "b")

# p-values adjusted for multiple testing
plot(res$p_adj[order(res$p_adj)], type = "b")
```



# Additional steps for microarray data

If you are using microarray data, you also need to use limma/voom to convert data...

give example code






Vignette info from template:


Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
#plot(1:10)
#plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.



Math expressions

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
#knitr::kable(head(mtcars, 10))
```


