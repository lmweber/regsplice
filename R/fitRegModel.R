#####################################
## Functions for regsplice package ##
## author: Lukas Weber             ##
#####################################


#' Fit regularized model (single gene).
#' 
#' Internal function to fit regularized model for a single gene.
#' 
#' In most cases the user will use the external function \code{\link{fitRegModel}}, which
#' can fit regularized models for multiple genes using parallelization.
#' \code{fitRegModel} calls \code{fitRegModelSingle} internally.
#' 
#' See documentation for \code{\link{fitRegModel}} for more details.
#' 
#' @family fitRegModelSingle fitGLMSingle fitNullModelSingle
#' @seealso \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}} 
#'   \code{\link{lrTest}} \code{\link[glmnet]{glmnet}} \code{\link[glmnet]{cv.glmnet}}
fitRegModelSingle <- function(X = NULL, Y, weights = NULL, 
                              group = NULL, nexons = NULL, 
                              alpha = 1, lambda_choice = c("lambda.min", "lambda.1se"), 
                              ...) {
  
  if (is.null(X)) X <- createDesignMatrix(group = group, nexons = nexons)
  lambda_choice <- match.arg(lambda_choice)
  if (is.null(weights)) weights <- rep(1, length(Y))
  
  # identify interaction columns
  int_cols <- grepl(":", colnames(X))
  
  fit <- glmnet::cv.glmnet(x = X, y = Y, weights = weights, 
                           alpha = alpha, penalty.factor = as.numeric(int_cols), 
                           standardize = FALSE, ...)
  
  ix_opt <- which(fit$lambda == fit[[lambda_choice]])
  dev <- deviance(fit$glmnet.fit)[ix_opt]
  df <- fit$glmnet.fit$df[ix_opt]
  
  return(list(fit = fit, dev = dev, df = df))
}




#' Fit regularized models.
#' 
#' Parallelized function to fit regularized models for multiple genes using the 
#' \code{glmnet} package.
#' 
#' Fits l1-regularized (lasso) models for each gene using the \code{glmnet} package.
#' Together with the null models from \code{\link{fitNullModel}}, these can then be used
#' to calculate likelihood ratio p-values using the function \code{\link{lrTest}}.
#' 
#' The l1-regularization (lasso) model fitting procedure in this function is designed to 
#' penalize interaction terms only. The fitted models therefore consist of all main
#' effect terms for exons and samples, together with some or all of the interaction
#' terms. The nested null models consist of the main effect terms only. Likelihood ratio
#' tests can therefore be calculated to compare the evidence for the two models.
#' 
#' For some genes, the regularized model will typically select zero interaction terms. In
#' these cases the fitted and null models are equivalent, so a likelihood ratio test
#' cannot be calculated. The \code{\link{lrTest}} function provides two possible
#' strategies for these cases â€” setting p-values for these genes to 1, or re-fitting a
#' full GLM containing all interaction terms. See documentation for \code{\link{lrTest}}
#' for more details.
#' 
#' @section Notes:
#' Interaction terms are identified by the column names of the design matrices in
#' \code{X_genes}. Column names containing a colon \code{:} are assumed to represent
#' interaction columns (for example \code{Exon2:Grp1}). This is the format generated by
#' the function \code{\link{createDesignMatrix}}.
#' 
#' The expression data matrices in \code{Y_genes} are assumed to be on a continuous
#' scale. RNA-seq count data can be transformed to a continuous scale using the
#' \code{voom} function in the \code{limma} package.
#' 
#' The call to \code{glmnet} sets the argument \code{standardize = FALSE}. 
#' Standardization is not required here since the design matrices in \code{X_genes} 
#' contain only indicator variables.
#' 
#' To speed up runtime, this function is parallelized using the \code{MulticoreParam}
#' function from the \code{BiocParallel} package, which works with Mac OSX and Linux. On
#' Windows systems, the code will run on a single core.
#' 
#' @param X_genes List of design matrices. Individual design matrices in the required 
#'   format can be created with the function \code{\link{createDesignMatrix}}. Note that 
#'   column names are used to identify interaction terms (see above). Can be set to
#'   \code{NULL}, in which case \code{group} and \code{nexons_genes} must be provided.
#' @param Y_genes List of expression data matrices. Assumed to be on a continuous scale, 
#'   for example transformed using the \code{voom} function from the \code{limma}
#'   package.
#' @param weights_genes Optional list of weights matrices, for example generated by
#'   \code{voom}.
#' @param group Optional vector of group membership identifiers for each sample. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param nexons_genes Optional vector containing number of exons for each gene. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param alpha Elastic net parameter \code{alpha} for \code{glmnet} fitting functions.
#'   Must be between 0 (ridge regression) and 1 (lasso). See \code{glmnet} documentation
#'   for details. Default is 1 (lasso).
#' @param lambda_choice Parameter to select which optimal lambda value to choose from the
#'   \code{cv.glmnet} cross validation fit. Choices are "lambda.min" (model with minimum
#'   cross-validated error) and "lambda.1se" (most regularized model with cross-validated
#'   error within one standard error of minimum). See \code{glmnet} documentation for
#'   more details. Default is "lambda.min".
#' @param return_fitted Logical; whether to return fitted model objects from
#'   \code{cv.glmnet}.
#' @param ncores Number of cores for parallel evaluation. Default is 1. Note that on
#'   Windows systems, the code will always run on a single core.
#' @param ... Other arguments to pass to \code{cv.glmnet} and \code{glmnet}.
#' 
#' @return Returns a list containing:
#' \itemize{
#'   fit_genes: (optional) fitted \code{cv.glmnet} model objects for each gene
#'   dev_genes: deviance of optimal fitted model for each gene
#'   df_genes: degrees of freedom of optimal fitted model for each gene
#' }
#' 
#' @family \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}}
#' @seealso \code{\link{fitRegModelSingle}} \code{\link{fitGLMSingle}}
#'   \code{\link{fitNullModelSingle}} \code{\link{lrTest}} \code{\link[glmnet]{glmnet}}
#'   \code{\link[glmnet]{cv.glmnet}}
#' 
#' @examples
#' set.seed(1)
#' group <- rep(c(0, 1), each=3)
#' nexons <- 8
#' X <- createDesignMatrix(group, nexons)
#' Y <- rnorm(nrow(X), mean=2, sd=1)
#' ix <- c(7, 8) + ( 8 * rep(0:5, each=2) )
#' Y[ix] <- Y[ix] + 1
#' fitRegModel(X, Y)
fitRegModel <- function(X_genes = NULL, Y_genes, weights_genes = NULL, 
                        group = NULL, nexons_genes = NULL, 
                        alpha = 1, lambda_choice = c("lambda.min", "lambda.1se"), 
                        return_fitted = FALSE, ncores = 1, ...) {
  
  if (!is.null(X_genes) && !is.list(X_genes)) {
    X_genes <- list(X_genes = X_genes)
  }
  if (!is.list(Y_genes)) {
    Y_genes <- list(Y_genes = Y_genes)
  }
  if (!is.null(weights_genes) && !is.list(weights_genes)) {
    weights_genes <- list(weights_genes = weights_genes)
  }
  
  FUN <- function(i) {
    fitRegModelSingle(X = X_genes[[i]], Y = Y_genes[[i]], weights = weights_genes[[i]], 
                      group = group, nexons = nexons_genes[i], 
                      alpha = alpha, lambda_choice = lambda_choice, ...)
  }
  BPPARAM <- BiocParallel::MulticoreParam(workers = ncores)
  n <- length(Y_genes)
  res <- BiocParallel::bplapply(seq_len(n), FUN = FUN, BPPARAM = BPPARAM)
  
  if (return_fitted == TRUE) fit_genes <- sapply(res, "[[", "fit")
  dev_genes <- sapply(res, "[[", "dev")
  df_genes <- sapply(res, "[[", "df")
  
  if (return_fitted == TRUE) {
    return(list(fit_genes = fit_genes, dev_genes = dev_genes, df_genes = df_genes))
  } else {
    return(list(dev_genes = dev_genes, df_genes = df_genes))
  }
}


