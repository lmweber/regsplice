#####################################
## Functions for regsplice package ##
## author: Lukas Weber             ##
#####################################


#' Fit null model (single gene).
#' 
#' Internal function to fit null model (no interaction terms) for a single gene.
#' 
#' In most cases the user will use the external function \code{\link{fitNullModel}}, 
#' which can fit null models for multiple genes using parallelization.
#' \code{fitNullModel} calls \code{fitNullModelSingle} internally.
#' 
#' See documentation for \code{\link{fitNullModel}} for more details.
#' 
#' @family fitRegModelSingle fitGLMSingle fitNullModelSingle
#' @seealso \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}} 
#'   \code{\link{lrTest}} \code{\link[stats]{glm}}
fitNullModelSingle <- function(X = NULL, Y, weights = NULL, 
                               group = NULL, nexons = NULL, ...) {
  
  if (is.null(X)) X <- createDesignMatrix(group = group, nexons = nexons)
  if (is.null(weights)) weights <- rep(1, length(Y))
  
  # identify interaction columns
  int_cols <- grepl(":", colnames(X))
  
  fit <- glm(Y ~ X[, !int_cols], weights = weights, ...)
  dev <- fit$deviance
  df <- fit$df.null - fit$df.residual
  
  return(list(fit = fit, dev = dev, df = df))
}



#' Fit null models.
#' 
#' Parallelized function to fit null models (zero interaction terms) for multiple genes 
#' using \code{glm}.
#' 
#' Fits null models for each gene using \code{glm}. Null models contain main effect terms
#' for exon and sample, but do not contain any interaction terms. These null models are
#' nested within the regularized models from \code{\link{fitRegModel}} or the full models
#' from \code{\link{GLM}}, which allows likelihood ratio tests to be calculated with the
#' function \code{\link{lrTest}}.
#' 
#' @param X_genes List of design matrices. Individual design matrices in the required 
#'   format can be created with the function \code{\link{createDesignMatrix}}. Note that 
#'   column names are used to identify interaction terms (see above). Can be set to
#'   \code{NULL}, in which case \code{group} and \code{nexons_genes} must be provided.
#' @param Y_genes List of expression data matrices. Assumed to be on a continuous scale, 
#'   for example transformed using the \code{voom} function from the \code{limma}
#'   package.
#' @param weights_genes Optional list of weights matrices, for example generated by
#'   \code{voom}.
#' @param group Optional vector of group membership identifiers for each sample. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param nexons_genes Optional vector containing number of exons for each gene. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param return_fitted Logical; whether to return fitted model objects from
#'   \code{glm}.
#' @param ncores Number of cores for parallel evaluation. Default is 1. Note that on
#'   Windows systems, the code will always run on a single core.
#' @param ... Other arguments to pass to \code{glm}.
#' 
#' @return Returns a list containing:
#' \itemize{
#'   fit_genes: (optional) fitted \code{glm} model objects for each gene
#'   dev_genes: deviance of fitted model for each gene
#'   df_genes: degrees of freedom of fitted model for each gene
#' }
#' 
#' @family \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}}
#' @seealso \code{\link{fitRegModelSingle}} \code{\link{fitGLMSingle}}
#'   \code{\link{fitNullModelSingle}} \code{\link{lrTest}} \code{\link[stats]{glm}}
#' 
#' @examples
#' set.seed(1)
#' group <- rep(c(0, 1), each=3)
#' nexons <- 8
#' X <- createDesignMatrix(group, nexons)
#' Y <- rnorm(nrow(X), mean=2, sd=1)
#' ix <- c(7, 8) + ( 8 * rep(0:5, each=2) )
#' Y[ix] <- Y[ix] + 1
#' fitNullModel(X, Y)
fitNullModel <- function(X_genes = NULL, Y_genes, weights_genes = NULL, 
                         group = NULL, nexons_genes = NULL, 
                         return_fitted = FALSE, ncores = 1, ...) {
  
  if (!is.list(X_genes)) X_genes <- list(X_genes = X_genes)
  if (!is.list(Y_genes)) Y_genes <- list(Y_genes = Y_genes)
  if (!is.list(weights_genes)) weights_genes <- list(weights_genes = weights_genes)
  
  FUN <- function(i) {
    fitNullModelSingle(X = X_genes[[i]], Y = Y_genes[[i]], weights = weights_genes[[i]], 
                       group = group, nexons = nexons_genes[i], ...)
  }
  BPPARAM <- BiocParallel::MulticoreParam(workers = ncores)
  n <- length(Y_genes)
  res <- BiocParallel::bplapply(seq_len(n), FUN = FUN, BPPARAM = BPPARAM)
  
  if (return_fitted == TRUE) fit_genes <- sapply(res, "[[", "fit")
  dev_genes <- sapply(res, "[[", "dev")
  df_genes <- sapply(res, "[[", "df")
  
  if (return_fitted == TRUE) {
    return(list(fit_genes = fit_genes, dev_genes = dev_genes, df_genes = df_genes))
  } else {
    return(list(dev_genes = dev_genes, df_genes = df_genes))
  }
}


