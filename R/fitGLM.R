#####################################
## Functions for regsplice package ##
## author: Lukas Weber             ##
#####################################


#' Fit full model with all interaction terms (single gene).
#' 
#' Internal function to fit full GLM (with all interaction terms) for a single gene.
#' 
#' In most cases the user will use the external function \code{\link{fitGLM}}, which can 
#' fit models for multiple genes using parallelization. \code{fitGLM} calls
#' \code{fitGLMSingle} internally.
#' 
#' See documentation for \code{\link{fitGLM}} for more details.
#' 
#' @family fitRegModelSingle fitGLMSingle fitNullModelSingle
#' @seealso \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}} 
#'   \code{\link{lrTest}} \code{\link[stats]{glm}}
fitGLMSingle <- function(X = NULL, Y, weights = NULL, 
                         group = NULL, nexons = NULL, ...) {
  
  if (is.null(X)) X <- createDesignMatrix(group = group, nexons = nexons)
  if (is.null(weights)) weights <- rep(1, length(Y))
  
  # identify interaction columns
  int_cols <- grepl(":", colnames(X))
  
  fit <- glm(Y ~ X, weights = weights, ...)
  dev <- fit$deviance
  df <- fit$df.null - fit$df.residual
  
  return(list(fit = fit, dev = dev, df = df))
}



#' Fit full models with all interaction terms.
#' 
#' Parallelized function to fit full GLMs (with all interaction terms) for multiple genes
#' using \code{glm}.
#' 
#' Fits full GLMs containing all interaction terms for each gene. Model fitting is done
#' with \code{glm}. These models can be used together with the nested null models (no
#' interaction terms) from \code{\link{fitNullModels}} to calculate likelihood ratio
#' tests with the function \code{\link{lrTest}}.
#' 
#' The full models are also used to replace fitted models containing zero interaction
#' terms if the option \code{when_null_selected = "GLM"} is used in \code{\link{lrTest}}
#' (see documentation for \code{\link{lrTest}} for more details).
#' 
#' The full models contain exon main effects, sample main effects, and all exon:group 
#' interaction terms. This is similar to the approach used in \code{voom-diffSlice}
#' (function \code{diffSplice} in the \code{limma} package).
#' 
#' @param X_genes List of design matrices. Individual design matrices in the required 
#'   format can be created with the function \code{\link{createDesignMatrix}}. Note that 
#'   column names are used to identify interaction terms (see above). Can be set to
#'   \code{NULL}, in which case \code{group} and \code{nexons_genes} must be provided.
#' @param Y_genes List of expression data matrices. Assumed to be on a continuous scale, 
#'   for example transformed using the \code{voom} function from the \code{limma}
#'   package.
#' @param weights_genes Optional list of weights matrices, for example generated by
#'   \code{voom}.
#' @param group Optional vector of group membership identifiers for each sample. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param nexons_genes Optional vector containing number of exons for each gene. Must be
#'   provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
#'   be called to generate design matrices.
#' @param return_fitted Logical; whether to return fitted model objects from
#'   \code{glm}.
#' @param ncores Number of cores for parallel evaluation. Default is 1. Note that on
#'   Windows systems, the code will always run on a single core.
#' @param ... Other arguments to pass to \code{glm}.
#' 
#' @return Returns a list containing:
#' \itemize{
#'   fit_genes: (optional) fitted \code{glm} model objects for each gene
#'   dev_genes: deviance of fitted model for each gene
#'   df_genes: degrees of freedom of fitted model for each gene
#' }
#' 
#' @family \code{\link{fitRegModel}} \code{\link{fitGLM}} \code{\link{fitNullModel}}
#' @seealso \code{\link{fitRegModelSingle}} \code{\link{fitGLMSingle}}
#'   \code{\link{fitNullModelSingle}} \code{\link{lrTest}} \code{\link[stats]{glm}}
#' 
#' @examples
#' set.seed(1)
#' group <- rep(c(0, 1), each=3)
#' nexons <- 8
#' X <- createDesignMatrix(group, nexons)
#' Y <- rnorm(nrow(X), mean=2, sd=1)
#' ix <- c(7, 8) + ( 8 * rep(0:5, each=2) )
#' Y[ix] <- Y[ix] + 1
#' fitGLM(X, Y)
fitGLM <- function(X_genes = NULL, Y_genes, weights_genes = NULL, 
                   group = NULL, nexons_genes = NULL, 
                   return_fitted = FALSE, ncores = 1, ...) {
  
  if (!is.null(X_genes) && !is.list(X_genes)) {
    X_genes <- list(X_genes = X_genes)
  }
  if (!is.list(Y_genes)) {
    Y_genes <- list(Y_genes = Y_genes)
  }
  if (!is.null(weights_genes) && !is.list(weights_genes)) {
    weights_genes <- list(weights_genes = weights_genes)
  }
  
  FUN <- function(i) {
    fitGLMSingle(X = X_genes[[i]], Y = Y_genes[[i]], weights = weights_genes[[i]], 
                 group = group, nexons = nexons_genes[i], ...)
  }
  BPPARAM <- BiocParallel::MulticoreParam(workers = ncores)
  n <- length(Y_genes)
  res <- BiocParallel::bplapply(seq_len(n), FUN = FUN, BPPARAM = BPPARAM)
  
  if (return_fitted == TRUE) fit_genes <- sapply(res, "[[", "fit")
  dev_genes <- sapply(res, "[[", "dev")
  df_genes <- sapply(res, "[[", "df")
  
  if (return_fitted == TRUE) {
    return(list(fit_genes = fit_genes, dev_genes = dev_genes, df_genes = df_genes))
  } else {
    return(list(dev_genes = dev_genes, df_genes = df_genes))
  }
}


