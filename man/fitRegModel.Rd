% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/fitRegModel.R
\name{fitRegModel}
\alias{fitRegModel}
\title{Fit regularized models.}
\usage{
fitRegModel(X_genes = NULL, Y_genes, weights_genes = NULL, group = NULL,
  nexons_genes = NULL, alpha = 1, lambda_choice = c("lambda.min",
  "lambda.1se"), return_fitted = FALSE, ncores = 1, ...)
}
\arguments{
\item{X_genes}{List of design matrices. Individual design matrices in the required
format can be created with the function \code{\link{createDesignMatrix}}. Note that
column names are used to identify interaction terms (see above). Can be set to
\code{NULL}, in which case \code{group} and \code{nexons_genes} must be provided.}

\item{Y_genes}{List of expression data matrices. Assumed to be on a continuous scale,
for example transformed using the \code{voom} function from the \code{limma}
package.}

\item{weights_genes}{Optional list of weights matrices, for example generated by
\code{voom}.}

\item{group}{Optional vector of group membership identifiers for each sample. Must be
provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
be called to generate design matrices.}

\item{nexons_genes}{Optional vector containing number of exons for each gene. Must be
provided if \code{X_genes = NULL}, so that \code{\link{createDesignMatrix}} can
be called to generate design matrices.}

\item{alpha}{Elastic net parameter \code{alpha} for \code{glmnet} fitting functions.
Must be between 0 (ridge regression) and 1 (lasso). See \code{glmnet} documentation
for details. Default is 1 (lasso).}

\item{lambda_choice}{Parameter to select which optimal lambda value to choose from the
\code{cv.glmnet} cross validation fit. Choices are "lambda.min" (model with minimum
cross-validated error) and "lambda.1se" (most regularized model with cross-validated
error within one standard error of minimum). See \code{glmnet} documentation for
more details. Default is "lambda.min".}

\item{return_fitted}{Logical; whether to return fitted model objects from
\code{cv.glmnet}.}

\item{ncores}{Number of cores for parallel evaluation. Default is 1. Note that on
Windows systems, the code will always run on a single core.}

\item{...}{Other arguments to pass to \code{cv.glmnet} and \code{glmnet}.}
}
\value{
Returns a list containing:
\itemize{
  fit_genes: (optional) fitted \code{cv.glmnet} model objects for each gene
  dev_genes: deviance of optimal fitted model for each gene
  df_genes: degrees of freedom of optimal fitted model for each gene
}
}
\description{
Parallelized function to fit regularized models for multiple genes using the
\code{glmnet} package.
}
\details{
Fits l1-regularized (lasso) models for each gene using the \code{glmnet} package.
Together with the null models from \code{\link{fitNullModel}}, these can then be used
to calculate likelihood ratio p-values using the function \code{\link{lrTest}}.

The l1-regularization (lasso) model fitting procedure in this function is designed to
penalize interaction terms only. The fitted models therefore consist of all main
effect terms for exons and samples, together with some or all of the interaction
terms. The nested null models consist of the main effect terms only. Likelihood ratio
tests can therefore be calculated to compare the evidence for the two models.

For some genes, the regularized model will typically select zero interaction terms. In
these cases the fitted and null models are equivalent, so a likelihood ratio test
cannot be calculated. The \code{\link{lrTest}} function provides two possible
strategies for these cases â€” setting p-values for these genes to 1, or re-fitting a
full GLM containing all interaction terms. See documentation for \code{\link{lrTest}}
for more details.
}
\section{Notes}{

Interaction terms are identified by the column names of the design matrices in
\code{X_genes}. Column names containing a colon \code{:} are assumed to represent
interaction columns (for example \code{Exon2:Grp1}). This is the format generated by
the function \code{\link{createDesignMatrix}}.

The expression data matrices in \code{Y_genes} are assumed to be on a continuous
scale. RNA-seq count data can be transformed to a continuous scale using the
\code{voom} function in the \code{limma} package.

The call to \code{glmnet} sets the argument \code{standardize = FALSE}.
Standardization is not required here since the design matrices in \code{X_genes}
contain only indicator variables.

To speed up runtime, this function is parallelized using the \code{MulticoreParam}
function from the \code{BiocParallel} package, which works with Mac OSX and Linux. On
Windows systems, the code will run on a single core.
}
\examples{
set.seed(1)
group <- rep(c(0, 1), each=3)
nexons <- 8
X <- createDesignMatrix(group, nexons)
Y <- rnorm(nrow(X), mean=2, sd=1)
ix <- c(7, 8) + ( 8 * rep(0:5, each=2) )
Y[ix] <- Y[ix] + 1
fitRegModel(X, Y)
}
\seealso{
\code{\link{fitRegModelSingle}} \code{\link{fitGLMSingle}}
  \code{\link{fitNullModelSingle}} \code{\link{lrTest}} \code{\link[glmnet]{glmnet}}
  \code{\link[glmnet]{cv.glmnet}}

Other X.code..link.fitRegModel....code..link.fitGLM....code..link.fitNullModel..: \code{\link{fitGLM}};
  \code{\link{fitNullModel}}
}

