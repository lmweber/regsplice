% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regsplice_wrapper.R
\name{regsplice}
\alias{regsplice}
\title{Wrapper function to run regsplice.}
\usage{
regsplice(counts, gene, condition, weights = NULL, alpha = 1,
  lambda_choice = c("lambda.min", "lambda.1se"),
  when_null_selected = c("ones", "GLM", "NA"), return_fitted = FALSE,
  n_cores_reg = NULL, n_cores_GLM = 1, n_cores_null = 1, seed = NULL,
  ...)
}
\arguments{
\item{counts}{RNA-seq read counts (matrix or data frame). Each row is an exon, and
each column is a biological sample.}

\item{gene}{Vector of gene IDs (character vector). Length is equal to the number of
rows in \code{counts}.}

\item{condition}{Biological conditions for each sample (character or numeric vector, 
or factor).}

\item{weights}{Optional weights (list of data frames or matrices), for example 
generated using \code{voom}.}

\item{alpha}{Elastic net parameter \code{alpha} for \code{glmnet} model fitting 
functions. Must be between 0 (ridge regression) and 1 (lasso). Default is 1 (lasso).
See \code{glmnet} documentation for details.}

\item{lambda_choice}{Parameter to select which optimal lambda value to choose from the
\code{cv.glmnet} cross validation fit. Choices are "lambda.min" (model with minimum 
cross-validated error) and "lambda.1se" (most regularized model with cross-validated
error within one standard error of minimum). Default is "lambda.min". See
\code{glmnet} documentation for more details.}

\item{when_null_selected}{Which option to use for genes where the lasso model selects 
zero interaction terms, i.e. identical to the null model. Options are \code{"ones"},
\code{"GLM"}, and \code{"NA"}. Default is \code{"ones"}. See \code{\link{LR_tests}}
for details.}

\item{return_fitted}{Whether to return fitted model objects. Default is FALSE.}

\item{n_cores_reg}{Number of cores for fitting regularized models. Default is 8, or
the maximum available if less than 8.}

\item{n_cores_GLM}{Number of cores for fitting GLMs. Default is 1, since this function
is already very fast.}

\item{n_cores_null}{Number of cores for fitting null models. Default is 1, since this
function is already very fast.}

\item{seed}{Random number generation seed (integer). Default is NULL. Provide an
integer value to set the random seed for reproducible results.}

\item{...}{Other arguments to pass to \code{cv.glmnet}, \code{glmnet}, or \code{glm}.}
}
\value{
Returns a list containing:
\itemize{
\item dev Deviance of fitted models for each gene.
\item df Degrees of freedom of fitted models for each gene.
\item fit Fitted model objects (if \code{return_fitted = TRUE}).
}
}
\description{
Wrapper function to run a complete regsplice analysis with one command.
}
\details{
This wrapper function runs the complete \emph{regsplice} pipeline with a single 
command. It calls each of the individual functions within the package in sequence. You
can also run the individual functions separately, which provides additional 
flexibility and insight into the statistical methodology. See the vignette for a 
description of the individual functions and an example workflow.

Required inputs are \code{counts} (matrix of RNA-seq counts), \code{gene} (vector of 
gene IDs), and \code{condition} (vector of biological conditions).

The gene ID vector \code{gene} must contain one entry for each exon, with repeated
entries for multiple exons within the same gene, so that its length is equal to the
number of rows in \code{counts}; the gene lengths are taken from the number of
repeated entries for each gene. Usually you will be able to construct the gene ID
vector from the row names of a raw data frame. See the vignette for an example.

See \code{\link{create_design_matrix}} for details about the model design matrices; 
\code{\link{fit_reg}}, \code{\link{fit_GLM}}, or \code{\link{fit_null}} for details
about the model fitting functions; and \code{\link{LR_tests}} for details about the
likelihood ratio tests.
}
\examples{
n_exons <- c(4, 11, 3, 2, 5, 5, 7, 9, 4, 20, 18, 3, 9)
n_genes <- length(n_exons)
gene <- paste0("gene", rep(1:n_genes, times = n_exons))
condition <- rep(c(0, 1), each = 3)

counts <- matrix(sample(100:200, sum(n_exons) * 6, replace = TRUE), ncol = 6)

regsplice(counts, gene, condition)

}
\seealso{
\code{\link{prepare_data}} \code{\link{create_design_matrix}} 
  \code{\link{fit_reg}} \code{\link{fit_GLM}} \code{\link{fit_null}} 
  \code{\link{LR_tests}}
}

